// Copyright (c) 2017, Herman Bergwerf. All rights reserved.
// Use of this source code is governed by an AGPL-3.0-style license
// that can be found in the LICENSE file.

part of qedb;

/// Compute result of applying [step], given the [previous] expression. In some
/// cases the computation is backwards. This means the substitution that is
/// applied to [previous] is computed in part based on the resulting expression.
///
/// This function is one of the most important functions in this library since
/// it reconstructs proof steps. The integrity of proofs largely relies on this
/// function.
Future<Expr> _computeProofStep(Session s, Expr previous, _StepData step,
    List<int> rearrangeableIds, ExprCompute compute) async {
  // If the step type is null, it is an existing step and only the step
  // expression was retrieved.
  if (step.type == null) {
    return step.expression;
  }

  switch (step.type) {
    // In the case of copyRule the resulting expression is generated earlier.
    case StepType.copyRule:
    case StepType.setExpression:
      return step.expression;

    case StepType.copyProof:
      throw new UnimplementedError('copyProof is not implemented');

    case StepType.rearrange:
      return previous.rearrangeAt(
          step.rearrangeFormat, step.position, rearrangeableIds);

    case StepType.substituteRule:
      final subs = step.reverseItself ? step.subs.inverted : step.subs;

      // First substitute rule to obtain mapping for checking the conditions.
      final mapping = new ExprMapping();
      Expr result;
      if (!step.reverseTarget) {
        result = previous.substituteAt(subs, step.position, mapping: mapping);
      } else {
        // Reversed evaluation means that the right sub-expression at this
        // position is used to construct the original expression. When evaluated
        // this must match the expression in [previous] at the step position.
        // From this a new rule can be constructed to substitute the
        // sub-expression into [previous].
        final original =
            step.subExprRight.substituteAt(subs, 0, mapping: mapping);
        result = previous.substituteAt(
            new Subs(original.evaluate(compute), step.subExprRight),
            step.position);
      }
      assert(result != null);

      // Retrieve conditions.
      final ruleConditions =
          await s.select(db.ruleCondition, WHERE({'rule_id': IS(step.ruleId)}));
      final substitutionIds = ruleConditions.map((c) => c.substitutionId);
      final subss = await getSubsMap(s, substitutionIds);

      // Check each condition.
      for (final condition in ruleConditions) {
        if (step.conditionProofs.containsKey(condition.id)) {
          // Get condition and proof substitution.
          final conditionSubs = subss[condition.substitutionId];

          final proof = step.conditionProofs[condition.id];
          final proofRule = await s.selectById(db.rule, proof.ruleId);
          final proofSubs = await getSubs(s, proofRule.substitutionId);

          // Just to make sure both substitutions are indeed set.
          assert(conditionSubs != null && proofSubs != null);

          // Reverse substitutions as specified.
          final pSubs = proofSubs.clone(invert: proof.reverseItself);
          final cSubs = conditionSubs.clone(invert: proof.reverseItself);

          // Compare condition with proof. The proof should be a superset of
          // the condition. The mapping generated by applying the related rule
          // at the given position is applied to the condition first.
          if (!cSubs.remap(mapping).compare(pSubs, compute)) {
            throw new UnprocessableEntityError('condition proof mismatch');
          }
        } else {
          throw new UnprocessableEntityError('missing condition proof');
        }
      }

      return result;

    case StepType.substituteFree:
      // Since subs must match literally, we can combine reverseItself and
      // reverseTarget and perform the operation in one direction.
      final subs = xor(step.reverseItself, step.reverseTarget)
          ? step.subs.inverted
          : step.subs;

      return previous.substituteAt(subs, step.position, literal: true);

    case StepType.substituteProof:
      throw new UnimplementedError('substituteProof is not implemented');
  }

  // Analyzer keeps complaining about the function not returning in all cases.
  throw new Error();
}
