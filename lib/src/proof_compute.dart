// Copyright (c) 2017, Herman Bergwerf. All rights reserved.
// Use of this source code is governed by an AGPL-3.0-style license
// that can be found in the LICENSE file.

part of qedb;

/// Compute result of applying [step], given the [previous] expression. In some
/// cases the computation is backwards. This means the substitution that is
/// applied to [previous] is computed in part based on the resulting expression.
///
/// This function is one of the most important functions in this library since
/// it reconstructs proof steps. The integrity of proofs largely relies on this
/// function.
Future<Expr> _computeProofStep(
    Session s,
    Expr previous,
    _StepData step,
    List<int> rearrangeableIds,
    List<Subs> freeConditions,
    ExprCompute compute) async {
  // If the step type is null, it is an existing step and only the step
  // expression was retrieved (as a result of which the type is null).
  if (step.type == null) {
    return step.expression;
  }

  switch (step.type) {
    // In the case of copyRule the resulting expression is generated earlier.
    case StepType.copyRule:
    case StepType.setExpression:
      return step.expression;

    case StepType.copyProof:
      throw new UnprocessableEntityError('copyProof is not implemented');

    case StepType.rearrange:
      return previous.rearrangeAt(
          step.rearrangeFormat, step.position, rearrangeableIds);

    case StepType.substituteRule:
      final subs = step.reverseItself ? step.subs.inverted : step.subs;

      // First substitute rule to obtain mapping for checking the conditions.
      // TODO: built more advanced substitution/mapping into eqlib.
      final mapping = new ExprMapping();
      Expr result;
      if (!step.reverseTarget) {
        // Expand mapping by matching right side of substitution against the
        // right side of expression.
        step.subExprRight.compare(subs.right, mapping);

        // Substitute rule.
        result = previous.substituteAt(subs, step.position, mapping: mapping);
      } else {
        // Expand mapping by matching right side of substitution against the
        // previous expression at [step.position].
        previous.flatten()[step.position].compare(subs.right, mapping);

        // Reversed evaluation means that the right sub-expression at this
        // position is used to construct the original expression. When evaluated
        // this must match the expression in [previous] at the step position.
        // From this a new rule can be constructed to substitute the
        // sub-expression into [previous].
        final original =
            step.subExprRight.substituteAt(subs, 0, mapping: mapping);
        result = previous.substituteAt(
            new Subs(original.evaluate(compute), step.subExprRight),
            step.position);
      }
      assert(result != null);

      // Retrieve conditions.
      final ruleConditions =
          await s.select(db.ruleCondition, WHERE({'rule_id': IS(step.ruleId)}));

      // Check each condition.
      for (final condition in ruleConditions) {
        if (step.conditionProofs.containsKey(condition.id)) {
          final proof = step.conditionProofs[condition.id];

          // Get condition substitution.
          final conditionSubs = (await getSubs(s, condition.substitutionId))
              .clone(invert: proof.reverseTarget);

          if (proof.entry.type == SubsType.rule) {
            final ruleId = proof.entry.referenceId;
            final rule = await s.selectById(db.rule, ruleId);
            final ruleSubs = (await getSubs(s, rule.substitutionId))
                .clone(invert: proof.reverseItself);

            // Check if the rule has no conditions.
            final ruleConditions = await s.select(
                db.ruleCondition, WHERE({'rule_id': IS(ruleId)}));
            if (ruleConditions.isNotEmpty) {
              throw new UnprocessableEntityError(
                  'condition proof rule has conditions');
            }

            // Compare condition with rule. The rule should be a superset of
            // the condition. The mapping generated by applying the parent rule
            // at the given position is applied to the condition first.
            if (!conditionSubs.remap(mapping).compare(ruleSubs, compute)) {
              throw new UnprocessableEntityError('condition proof mismatch');
            }
          } else if (proof.entry.type == SubsType.free) {
            final freeCondition = freeConditions[proof.entry.referenceId]
                .clone(invert: proof.reverseItself);

            // Must be a literal match by convention.
            if (conditionSubs.remap(mapping) != freeCondition) {
              throw new UnprocessableEntityError('condition proof mismatch');
            }
          } else {
            throw new UnprocessableEntityError(
                'unimplemented condition proof type');
          }
        } else {
          throw new UnprocessableEntityError('missing condition proof');
        }
      }

      return result;

    case StepType.substituteFree:
      // Since subs must match literally, we can combine reverseItself and
      // reverseTarget and perform the operation in one direction.
      final subs = xor(step.reverseItself, step.reverseTarget)
          ? step.subs.inverted
          : step.subs;

      return previous.substituteAt(subs, step.position, literal: true);

    case StepType.substituteProof:
      throw new UnprocessableEntityError('substituteProof is not implemented');
  }

  // Analyzer keeps complaining about the function not returning in all cases.
  throw new Error();
}
